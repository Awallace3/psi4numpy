# A simple Psi 4 input script to compute a RHF reference using second-order optimizations
# Requires scipy numpy 1.7.2+
#
# Created by: Daniel G. A. Smith
# Date: 2/27/15
# License: GPL v3.0
#

import time
import numpy as np
np.set_printoptions(precision=3, linewidth=200, suppress=True)
from helper_HF import *

# Memory for Psi4 in GB
memory 2 GB

# Memory for numpy in GB
numpy_memory = 2

molecule mol {
C    1.39410    0.00000   0.00000
C    0.69705   -1.20732   0.00000
C   -0.69705   -1.20732   0.00000
C   -1.39410    0.00000   0.00000
C   -0.69705    1.20732   0.00000
C    0.69705    1.20732   0.00000
H    2.47618    0.00000   0.00000
H    1.23809   -2.14444   0.00000
H   -1.23809   -2.14444   0.00000
H   -2.47618    0.00000   0.00000
H   -1.23809    2.14444   0.00000
H    1.23809    2.14444   0.00000
symmetry c1
}

set {
<<<<<<< HEAD
basis aug-cc-pVDZ
=======
basis cc-pVDZ
e_convergence 1e1
d_convergence 1e1
>>>>>>> 39978691f92cc4f7945123c7822a86626e09028d
}

# Knobs
E_conv = 1.e-8
<<<<<<< HEAD
D_conv = 1.e-5
max_macro = 20
max_micro = 4
micro_conv = 1.e-3
micro_print = False
=======
D_conv = 1.e-4
max_micro = 4
micro_conv = 1.e-10
micro_print = True
>>>>>>> 39978691f92cc4f7945123c7822a86626e09028d

# Build objects
diis = DIIS_helper()
hf = helper_HF(psi4, energy, mol, scf_type='DF', guess='SAD')
ndocc = hf.ndocc
nvirt = hf.nvirt


print('\nStart RHF iterations:\n')
t = time.time()
E = 0.0
Eold = 0.0
iter_type = 'CORE'

def Hx(x, Co, Cv, parts = False):
    F  = np.einsum('mp,pn->mn', moF[:ndocc, :ndocc], x)
    F += np.einsum('pm,np->nm', moF[ndocc:, ndocc:], -x)
    F *= -4

    # Build two electron part, M = -4 (4 G_{mnip} - g_{mpin} - g_{npim}) K_{ip}
    C_right = np.einsum('ia,sa->si', -x, Cv)
    J, K = hf.build_jk(Co, C_right)
    M    = (Co.T).dot(4 * J - K.T - K).dot(Cv)
    M   *= -4

    if parts:
        return (F, M)
    else:
        return F + M

for SCF_ITER in range(1, max_macro):

    # Build new fock matrix
    F = hf.build_fock()

    # DIIS error and update
    diis_e = F.dot(hf.Da).dot(hf.S) - hf.S.dot(hf.Da).dot(F)
<<<<<<< HEAD
    diis_e = (hf.A).dot(diis_e).dot(hf.A)
=======
    diis_e = (hf.A).dot(diis_e).dot(hf.A) 
>>>>>>> 39978691f92cc4f7945123c7822a86626e09028d
    diis.add(F, diis_e)

    # SCF energy and update
    scf_e = hf.compute_hf_energy()
    dRMS = np.mean(diis_e ** 2) ** 0.5
    print 'RHF Iteration %3d: Energy = %4.16f   dE = % 1.5E   dRMS = %1.5E   %s' % (SCF_ITER, hf.scf_e, (hf.scf_e - Eold), dRMS, iter_type)
    if (abs(hf.scf_e - Eold) < E_conv) and (dRMS < D_conv):
        break

    Eold = hf.scf_e
    Dold = hf.Da

    # Build MO fock matrix and gradient
    Co = hf.Ca[:, :ndocc]
    Cv = hf.Ca[:, ndocc:]
    moF = np.einsum('ui,vj,uv->ij', hf.Ca, hf.Ca, F)
    gradient = -4 * moF[:ndocc, ndocc:]
    grad_dot = np.vdot(gradient, gradient)

    if grad_dot < (D_conv):
        grad_dot = D_conv

    if (np.abs(np.max(gradient)) > 0.2):
        F = diis.extrapolate()
        eps, C = hf.diag(F)
        hf.set_Cleft(C)
        iter_type = 'DIIS'
    else:

        # Build preconditioner
        eps = np.diag(moF)
        precon = -4 * (eps[:ndocc].reshape(-1, 1) - eps[ndocc:])

        # Build guess
        guess_x = gradient / precon
        x = guess_x.copy()

        # CG setup
        r = gradient - Hx(guess_x, Co, Cv)
        z = r / precon
        p = z.copy()

        rms = np.mean(np.vdot(r, r) / grad_dot) ** 0.5
        if micro_print:
            print('Micro Iteration %2d: RMS = %1.5e' %  (0, rms))

        # CG iterations
        for rot_iter in range(max_micro):
            Ap = Hx(p, Co, Cv)

            rz = np.vdot(r, z)
            alpha = rz / np.vdot(p, Ap)

            # Hessian is non-singular
            if alpha < 0:
                x = guess_x
                break

            x += alpha * p
            r -= alpha * Ap

            rms = np.mean(np.vdot(r, r) / grad_dot) ** 0.5

            # Were not converging
            if rms > 1:
                x = guess_x
                break

            if micro_print:
                print('Micro Iteration %2d: RMS = %1.5e' %  (rot_iter + 1, rms))
            if rms < micro_conv:
                break

            z = r / precon
            beta = np.vdot(r, z) / rz
            p = z + beta * p

        # Build full x (antisymmetric) and exponentiate
        R = np.zeros_like(hf.Ca)
        R[:ndocc, ndocc:] = x
        R[ndocc:, :ndocc] = -x.T

        U  = R.copy()
        U[np.diag_indices_from(hf.A)] += 1
        U += 0.5 * np.dot(R, R)
        U += (1.0/6.0) * np.dot(R, R).dot(R)

        # Easy acess to shmidt orthogonalization
        U, r = np.linalg.qr(U.T)

        # Rotate and set orbitals
        C = hf.Ca.dot(U)
        hf.set_Cleft(C)
        iter_type = 'SOSCF, nmicro ' + str(rot_iter + 1)

print 'Total time taken for SCF iterations: %.3f seconds \n' % (time.time()-t)

#print 'Final SCF energy:     %.8f hartree' % hf.scf_e
#RHF_E_psi = energy('RHF')
#compare_values(RHF_E_psi, hf.scf_e, 6, 'RHF Energy')


