# A simple Psi 4 input script to compute a RHF reference using second-order optimizations
# Requires scipy numpy 1.7.2+
#
# Created by: Daniel G. A. Smith
# Date: 2/27/15
# License: GPL v3.0
#

import time
import numpy as np
np.set_printoptions(precision=3, linewidth=200, suppress=True)
from helper_HF import *

# Memory for Psi4 in GB
memory 2 GB

# Memory for numpy in GB
numpy_memory = 2

molecule mol {
C    1.39410    0.00000   0.00000
C    0.69705   -1.20732   0.00000
C   -0.69705   -1.20732   0.00000
C   -1.39410    0.00000   0.00000
C   -0.69705    1.20732   0.00000
C    0.69705    1.20732   0.00000
H    2.47618    0.00000   0.00000
H    1.23809   -2.14444   0.00000
H   -1.23809   -2.14444   0.00000
H   -2.47618    0.00000   0.00000
H   -1.23809    2.14444   0.00000
H    1.23809    2.14444   0.00000
symmetry c1
}

set {
basis cc-pVDZ
e_convergence 1e1
d_convergence 1e1
}

# Knobs
E_conv = 1.e-8
D_conv = 1.e-4
max_micro = 4
micro_conv = 1.e-10
micro_print = True

# Build objects
diis = DIIS_helper()
hf = helper_HF(psi4, energy, mol, scf_type='DF', guess='SAD')
ndocc = hf.ndocc
nvirt = hf.nvirt


print('\nStart RHF iterations:\n')
t = time.time()
E = 0.0
Eold = 0.0
Dold = 0.0
iter_type = 'DIAG'

for SCF_ITER in range(1, 20):

    # Build new fock matrix
    F = hf.build_fock()

    # DIIS error and update
    diis_e = F.dot(hf.Da).dot(hf.S) - hf.S.dot(hf.Da).dot(F)
    diis_e = (hf.A).dot(diis_e).dot(hf.A) 
    diis.add(F, diis_e)

    # SCF energy and update
    scf_e = hf.compute_hf_energy()
    dRMS = np.sum(np.power(hf.Da - Dold, 2)) ** 0.5
    print 'RHF Iteration %3d: Energy = %4.16f   dE = % 1.5E   dRMS = %1.5E   %s' % (SCF_ITER, hf.scf_e, (hf.scf_e - Eold), dRMS, iter_type)
    if (abs(hf.scf_e - Eold) < E_conv) and (dRMS < D_conv):
        break

    Co = hf.Ca[:, :ndocc]
    print np.sum(np.abs(np.einsum('pj,qj->pq', Co, Co) - Dold) > 1.e-8)
    Eold = hf.scf_e
    Dold = hf.Da

    # Build MO fock matrix and gradient
    Co = hf.Ca[:, :ndocc]
    Cv = hf.Ca[:, ndocc:]
    moF = np.einsum('ui,vj,uv->ij', hf.Ca, hf.Ca, F)
    gradient = -4 * moF[:ndocc, ndocc:]
    grad_norm = np.linalg.norm(gradient)

    if (grad_norm > 1):
        F = diis.extrapolate()
        eps, C = hf.diag(F)
        hf.set_Cleft(C)
        iter_type = 'DIIS'
    else:

        # DIIS helper and initial guess
        rdiis = DIIS_helper()
        eps = np.diag(moF)
        ia_denom = (-eps[:ndocc].reshape(-1, 1) + eps[ndocc:])
        x = gradient / (4 * ia_denom)
        xold = np.zeros_like(x)
        tmp = 0

        for rot_iter in range(max_micro):
            # Since only ov rotations are non-redundant the code is greatly simplified
            # One electron part, F = -4 (F_{mp} K_{np} + F_{pn} K_{mp})
            F  = np.einsum('mp,pn->mn', moF[:ndocc, :ndocc], x)
            F += np.einsum('pm,np->nm', moF[ndocc:, ndocc:], -x)
            F *= -4

            # Build two electron part, M = -4 (4 G_{mnip} - g_{mpin} - g_{npim}) K_{ip}
            C_right = np.einsum('ia,sa->si', -x, Cv)
            cd = np.einsum('pj,qj->pq', Co, C_right)
            print np.sum(np.abs(cd - tmp) > 1.e-8)
            J, K = hf.build_jk(Co, C_right)
            tmp = cd

            M    = (Co.T).dot(4 * J - K.T - K).dot(Cv)
            M   *= -4

            # New guess and diis
            # M + F = gradient, 1 = (gradient - M) / F
            x = x * (gradient - M) / F
            rdiis.add(x, x - xold)
            x = rdiis.extrapolate()

            rms = np.mean((x - xold) ** 2) ** 0.5
            if micro_print:
                print('Micro Iteration %2d: RMS = %1.5e' %  (rot_iter + 1, rms))
            if rms < micro_conv:
                break
            xold = x

        # Build and exponentiate U
        U = np.zeros_like(hf.Ca)
        U[:ndocc, ndocc:] = x
        U[ndocc:, :ndocc] = -x.T

        U += 0.5 * np.dot(U, U)
        U[np.diag_indices_from(hf.A)] += 1

        # Easy acess to shmidt orthogonalization
        U, r = np.linalg.qr(U.T)

        # Rotate and set orbitals
        C = hf.Ca.dot(U)
        hf.set_Cleft(C)
        iter_type = 'SOSCF, nmicro ' + str(rot_iter + 1)

print 'Total time taken for SCF iterations: %.3f seconds \n' % (time.time()-t)

print 'Final SCF energy:     %.8f hartree' % hf.scf_e
RHF_E_psi = energy('RHF')
compare_values(RHF_E_psi, hf.scf_e, 6, 'RHF Energy')


