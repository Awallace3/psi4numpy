# A simple Psi 4 input script to compute a SCF reference using Psi4's libJK
# Requires numpy 1.7.2+
#
# Created by: Daniel G. A. Smith
# Date: 4/1/15
# License: GPL v3.0
#

import time
import numpy as np
from helper_HF import *
np.set_printoptions(precision=5, linewidth=200, suppress=True)

# Memory for Psi4 in GB
memory 2 GB

# Memory for numpy in GB
numpy_memory = 2

# Benzene
molecule mol {
C    1.39410    0.00000   0.00000
C    0.69705   -1.20732   0.00000
C   -0.69705   -1.20732   0.00000
C   -1.39410    0.00000   0.00000
C   -0.69705    1.20732   0.00000
C    0.69705    1.20732   0.00000
H    2.47618    0.00000   0.00000
H    1.23809   -2.14444   0.00000
H   -1.23809   -2.14444   0.00000
H   -2.47618    0.00000   0.00000
H   -1.23809    2.14444   0.00000
H    1.23809    2.14444   0.00000

symmetry c1
}

set {
basis cc-pVDZ
scf_type df
e_convergence 1e-8
}

# Set defaults
maxiter = 40
E_conv = 1.0E-6
D_conv = 1.0E-3

# Integral generation from Psi4's MintsHelper
t = time.time()
wfn = psi4.new_wavefunction(mol, psi4.get_global_option('BASIS'))
mints = MintsHelper(wfn.basisset())
S = np.asarray(mints.ao_overlap())

# Get nbf and ndocc for closed shell molecules
nbf = S.shape[0]
ndocc = sum(mol.Z(A) for A in range(mol.natom())) / 2
ndocc = int(ndocc)

print '\nNumber of occupied orbitals: %d' % ndocc
print 'Number of basis functions: %d' % nbf

V = np.asarray(mints.ao_potential())
T = np.asarray(mints.ao_kinetic())

print '\nTotal time taken for integrals: %.3f seconds.' % (time.time()-t)

t = time.time()

# Build H_core
H = T + V

# Orthogonalizer A = S^(-1/2)
A = mints.ao_overlap()
A.power(-0.5, 1.e-16)
A = np.asarray(A)

# Calculate initial core guess
Hp = A.dot(H).dot(A)
e, C2 = np.linalg.eigh(Hp)
C = A.dot(C2)
Cocc = C[:, :ndocc]
D = np.einsum('pi,qi->pq', Cocc, Cocc)

t = time.time()
E = 0.0
Enuc = mol.nuclear_repulsion_energy()
Eold = 0.0
Dold = np.zeros_like(D)

Fock_list = []
DIIS_error = []

# Build a C matrix and share data with the numpy array npC
C = Matrix(nbf, ndocc)
npC = np.asarray(C)
npC[:] = Cocc

# Initialize the JK object
jk = JK.build_JK(wfn.basisset())
jk.initialize()
jk.C_left().append(C)

# Build a DIIS helper object
diis = DIIS_helper()

print('\nTotal time taken for setup: %.3f seconds' % (time.time() - t))

print('\nStart SCF iterations:\n')
t = time.time()

for SCF_ITER in range(1, maxiter + 1):

    npC[:] = Cocc
    jk.compute()

    # Build fock matrix
    J = np.asarray(jk.J()[0])
    K = np.asarray(jk.K()[0])
    F = H + J * 2 - K

    # DIIS error build and update
    diis_e = F.dot(D).dot(S) - S.dot(D).dot(F)
    diis_e = A.dot(diis_e).dot(A)
    diis.add(F, diis_e)

    # SCF energy and update
    SCF_E = np.einsum('pq,pq->', F + H, D) + Enuc
    dRMS = np.sum(np.power(D - Dold, 2)) ** 0.5

    print('SCF Iteration %3d: Energy = %4.16f   dE = % 1.5E   dRMS = %1.5E'
          % (SCF_ITER, SCF_E, (SCF_E - Eold), dRMS))
    if (abs(SCF_E - Eold) < E_conv) and (dRMS < D_conv):
        break

    Eold = SCF_E
    Dold = D

    F = diis.extrapolate()

    # Diagonalize Fock matrix
    Fp = A.dot(F).dot(A)
    e, C2 = np.linalg.eigh(Fp)
    C = A.dot(C2)
    Cocc = C[:, :ndocc]
    D = np.einsum('pi,qi->pq', Cocc, Cocc)

    if SCF_ITER == maxiter:
        clean()
        raise Exception("Maximum number of SCF cycles exceeded.")

print('Total time for SCF iterations: %.3f seconds \n' % (time.time() - t))

print('Final SCF energy: %.8f hartree' % SCF_E)
SCF_E_psi = energy('SCF')
compare_values(SCF_E_psi, SCF_E, 6, 'SCF Energy')
