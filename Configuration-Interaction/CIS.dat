# A simple Psi 4 script to compute CCSD from a RHF reference
# Scipy and numpy python modules are required
#
# Algorithms were taken directly from Daniel Crawford's programming website:
# http://sirius.chem.vt.edu/wiki/doku.php?id=crawdad:programming
# Special thanks to Lori Burns for integral help

import time
import numpy as np
from scipy import linalg as SLA
np.set_printoptions(precision=8, linewidth=200, suppress=True)

memory 2 GB

numpy_memory = 2

def pexit():
    clean()
    raise Exception("Exiting Psi4")

# molecule mol {
# O
# H 1 1.1
# H 1 1.1 2 104
# symmetry c1
# }

molecule mol {
O   0.000000000000  -0.143225816552   0.000000000000
H   1.638036840407   1.136548822547  -0.000000000000
H  -1.638036840407   1.136548822547  -0.000000000000
units bohr
symmetry c1
}

# molecule mol {
# H
# H 1 0.73257098
# symmetry c1
# }


set {
basis sto-3G
scf_type pk
guess core
mp2_type conv
freeze_core false
e_convergence 1e-10
d_convergence 1e-10
}

# First compute RHF energy using Psi4
energy('RHF')

# Grab data from 
wfn = wavefunction()
# Coefficient Matrix
C = np.array(wfn.Ca())
# Double occupied orbitals
ndocc = wfn.doccpi()[0]
# Number of molecular orbitals
nmo = wfn.nmo()
# SCF energy
SCF_E = wfn.energy()
# Orbital energies
eps = wfn.epsilon_a()
eps = np.array([eps.get(x) for x in range(C.shape[0])])

# Compute size of SO-ERI tensor in GB
ERI_Size = (nmo**4)*(2**4)*8.0 / 1E9
print "\nSize of the SO ERI tensor will be %4.2f GB." % ERI_Size
memory_footprint = ERI_Size*5.2
if memory_footprint > numpy_memory:
    clean()
    raise Exception("Estimated memory utilization (%4.2f GB) exceeds numpy_memory limit of %4.2f GB." % (memory_footprint, numpy_memory))

# Integral generation from Psi4's MintsHelper
t = time.time()
mints = MintsHelper()
I = np.array(mints.ao_eri())
I = I.reshape(nmo, nmo, nmo, nmo)
H = np.array(mints.ao_kinetic()) + np.array(mints.ao_potential())

print '\nTotal time taken for ERI integrals: %.3f seconds.\n' % (time.time()-t)

#Make spin-orbital MO
t=time.time()
print 'Starting AO -> spin-orbital MO transformation...'
nso = nmo * 2

MO = np.einsum('rJ,pqrs->pqJs', C, I)
MO = np.einsum('pI,pqJs->IqJs', C, MO)
MO = np.einsum('sB,IqJs->IqJB', C, MO)
MO = np.einsum('qA,IqJB->IAJB', C, MO)

# Tile MO array so that we have alternating alpha/beta spin orbitals
MO = np.repeat(MO, 2, axis=0)
MO = np.repeat(MO, 2, axis=1)
MO = np.repeat(MO, 2, axis=2)
MO = np.repeat(MO, 2, axis=3)

# Build spin mask
spin_ind = np.arange(nso, dtype=np.int) % 2
spin_mask = (spin_ind.reshape(-1, 1, 1, 1) == spin_ind.reshape(-1, 1, 1))
spin_mask = spin_mask * (spin_ind.reshape(-1, 1) == spin_ind)

# Compute antisymmetrized MO integrals
MO *= spin_mask
MO = MO - MO.swapaxes(1, 3)
MO = MO.swapaxes(1, 2)
print '..finished transformation in %.3f seconds.\n' % (time.time()-t)

# Update nocc and nvirt
nocc = ndocc * 2
nvirt = MO.shape[0] - nocc

#Extend eigenvalues
eps = np.repeat(eps, 2)
Eocc = eps[:nocc]
Evirt = eps[nocc:]

### Build so Fock matirx

# Update H, transform to MO basis and tile for alpha/beta spin
H = np.einsum('uj,vi,uv', C, C, H)
H = np.repeat(H, 2, axis=0)
H = np.repeat(H, 2, axis=1)

# Make H block diagonal
spin_ind = np.arange(H.shape[0], dtype=np.int) % 2
H *= (spin_ind.reshape(-1, 1) == spin_ind)

# Compute Fock matrix
F = H + np.einsum('pmqm->pq', MO[:, :nocc, :, :nocc])

o = slice(0, nocc)
v = slice(nocc, MO.shape[0])

# Build CIS matrix
dij = np.diag(np.ones(nocc))
dab = np.diag(np.ones(nvirt))

CIS = np.einsum('ab,ij->iajb', F[v, v], dij)
CIS -= np.einsum('ij,ab->iajb', F[o, o], dab)
CIS += np.einsum('ajib->iajb', MO[v, o, o, v])

CIS = CIS.reshape(40, 40)
print CIS[:10, :10]
e, C2 = SLA.eigh(CIS)
print e
#print C2

