# A simple Psi 4 script to compute CCSD from a RHF reference
# Scipy and numpy python modules are required
#
# Algorithms were taken directly from Daniel Crawford's programming website:
# http://sirius.chem.vt.edu/wiki/doku.php?id=crawdad:programming
# Special thanks to Lori Burns for integral help

import time
import numpy as np
from scipy import linalg as SLA
np.set_printoptions(precision=5, linewidth=200, suppress=True)

memory 2 GB

numpy_memory = 2

def pexit():
    clean()
    raise Exception("Exiting Psi4")

# molecule mol {
# O
# H 1 1.1
# H 1 1.1 2 104
# symmetry c1
# }

molecule mol {
O   0.000000000000  -0.143225816552   0.000000000000
H   1.638036840407   1.136548822547  -0.000000000000
H  -1.638036840407   1.136548822547  -0.000000000000
units bohr
symmetry c1
}

# molecule mol {
# H
# H 1 0.73257098
# symmetry c1
# }


set {
basis sto-3G
scf_type pk
guess core
mp2_type conv
freeze_core false
e_convergence 1e-10
d_convergence 1e-10
}

# First compute RHF energy using Psi4
energy('RHF')

# Grab data from 
wfn = wavefunction()
# Coefficient Matrix
C = np.array(wfn.Ca())
# Double occupied orbitals
ndocc = wfn.doccpi()[0]
# Number of molecular orbitals
nmo = wfn.nmo()
# SCF energy
SCF_E = wfn.energy()
# Orbital energies
eps = wfn.epsilon_a()
eps = np.array([eps.get(x) for x in range(C.shape[0])])

# Compute size of SO-ERI tensor in GB
ERI_Size = (nmo**4)*(2**4)*8.0 / 1E9
print "\nSize of the SO ERI tensor will be %4.2f GB." % ERI_Size
memory_footprint = ERI_Size*5.2
if memory_footprint > numpy_memory:
    clean()
    raise Exception("Estimated memory utilization (%4.2f GB) exceeds numpy_memory limit of %4.2f GB." % (memory_footprint, numpy_memory))

# Integral generation from Psi4's MintsHelper
t = time.time()
mints = MintsHelper()
I = np.array(mints.ao_eri())
I = I.reshape(nmo, nmo, nmo, nmo)
H = np.array(mints.ao_kinetic()) + np.array(mints.ao_potential())

print '\nTotal time taken for ERI integrals: %.3f seconds.\n' % (time.time()-t)

#Make spin-orbital MO
t=time.time()
print 'Starting AO -> spin-orbital MO transformation...'
nso = nmo * 2

MO = np.einsum('rJ,pqrs->pqJs', C, I)
MO = np.einsum('pI,pqJs->IqJs', C, MO)
MO = np.einsum('sB,IqJs->IqJB', C, MO)
MO = np.einsum('qA,IqJB->IAJB', C, MO)

# Tile MO array so that we have alternating alpha/beta spin orbitals
MO = np.repeat(MO, 2, axis=0)
MO = np.repeat(MO, 2, axis=1)
MO = np.repeat(MO, 2, axis=2)
MO = np.repeat(MO, 2, axis=3)

# Build spin mask
spin_ind = np.arange(nso, dtype=np.int) % 2
spin_mask = (spin_ind.reshape(-1, 1, 1, 1) == spin_ind.reshape(-1, 1, 1))
spin_mask = spin_mask * (spin_ind.reshape(-1, 1) == spin_ind)

# Compute antisymmetrized MO integrals
MO *= spin_mask
MO = MO - MO.swapaxes(1, 3)
MO = MO.swapaxes(1, 2)
print '..finished transformation in %.3f seconds.\n' % (time.time()-t)

# Update nocc and nvirt
nocc = ndocc * 2
nvirt = MO.shape[0] - nocc

#Extend eigenvalues
eps = np.repeat(eps, 2)
Eocc = eps[:nocc]
Evirt = eps[nocc:]

# DPD approach to CCSD equations
# See: http://sirius.chem.vt.edu/wiki/doku.php?id=crawdad:programming

# occ orbitals i, j, k, l, m, n
# virt orbitals a, b, c, d, e, f
# all oribitals p, q, r, s, t, u, v


#Bulid Eqn 9: tilde{\Tau}) 
def build_tilde_tau(t1, t2):
    ttau = t2.copy()
    tmp = 0.5 * np.einsum('ia,jb->ijab', t1, t1)
    ttau += tmp
    ttau -= tmp.swapaxes(2, 3)
    return ttau


#Build Eqn 10: \Tau) 
def build_tau(t1, t2):
    ttau = t2.copy()
    tmp = np.einsum('ia,jb->ijab', t1, t1)
    ttau += tmp
    ttau -= tmp.swapaxes(2, 3)
    return ttau


#Build Eqn 3:
def build_Fae(t1, t2):
    Fae = F[nocc:, nocc:].copy()
    Fae[np.diag_indices_from(Fae)] = 0

    Fae -= 0.5 * np.einsum('me,ma->ae', F[:nocc, nocc:], t1)
    Fae += np.einsum('mf,mafe->ae', t1, MO[:nocc, nocc:, nocc:, nocc:])

    tmp_tau = build_tilde_tau(t1, t2)
    Fae -= 0.5 * np.einsum('mnaf,mnef->ae', tmp_tau, MO[:nocc, :nocc, nocc:, nocc:])
    return Fae


#Build Eqn 4:
def build_Fmi(t1, t2):
    Fmi = F[:nocc, :nocc].copy()
    Fmi[np.diag_indices_from(Fmi)] = 0

    Fmi += 0.5 * np.einsum('ie,me->mi', t1, F[:nocc, nocc:])
    Fmi += np.einsum('ne,mnie->mi', t1, MO[:nocc, :nocc:, :nocc, nocc:])

    tmp_tau = build_tilde_tau(t1, t2)
    Fmi += 0.5 * np.einsum('inef,mnef->mi', tmp_tau, MO[:nocc, :nocc, nocc:, nocc:])
    return Fmi


#Build Eqn 5:
def build_Fme(t1, t2):
    Fme = F[:nocc, nocc:].copy()
    Fme += np.einsum('nf,mnef->me', t1, MO[:nocc, :nocc, nocc:, nocc:])
    return Fme


#Build Eqn 6:
def build_Wmnij(t1, t2):
    Wmnij = MO[:nocc, :nocc, :nocc, :nocc].copy()

    Pij = np.einsum('je,mnie->mnij', t1, MO[:nocc, :nocc, :nocc, nocc:])
    Wmnij += Pij
    Wmnij -= Pij.swapaxes(2, 3)

    tmp_tau = build_tau(t1, t2)
    Wmnij += 0.25 * np.einsum('ijef,mnef->mnij', tmp_tau, MO[:nocc, :nocc, nocc:, nocc:])
    return Wmnij


#Build Eqn 7:
def build_Wabef(t1, t2):
    Wabef = MO[nocc:, nocc:, nocc:, nocc:].copy()

    Pab = np.einsum('mb,amef->abef', t1, MO[nocc:, :nocc, nocc:, nocc:])
    Wabef -= Pab
    Wabef += Pab.swapaxes(0, 1)

    tmp_tau = build_tau(t1, t2)
    Wabef += 0.25 * np.einsum('mnab,mnef->abef', tmp_tau, MO[:nocc, :nocc, nocc:, nocc:])
    return Wabef


#Build Eqn 8:
def build_Wmbej(t1, t2):
    Wmbej = MO[:nocc, nocc:, nocc:, :nocc].copy()
    Wmbej += np.einsum('jf,mbef->mbej', t1, MO[:nocc, nocc:, nocc:, nocc:])
    Wmbej -= np.einsum('nb,mnej->mbej', t1, MO[:nocc, :nocc, nocc:, :nocc])

    tmp = (0.5 * t2) + np.einsum('jf,nb->jnfb', t1, t1)
    Wmbej -= np.einsum('jnfb,mnef->mbej', tmp, MO[:nocc, :nocc, nocc:, nocc:])
    return Wmbej


### Build so Fock matirx

# Update H, transform to MO basis and tile for alpha/beta spin
H = np.einsum('uj,vi,uv', C, C, H)
H = np.repeat(H, 2, axis=0)
H = np.repeat(H, 2, axis=1)

# Make H block diagonal
spin_ind = np.arange(H.shape[0], dtype=np.int) % 2
H *= (spin_ind.reshape(-1, 1) == spin_ind)

# Compute Fock matrix
F = H + np.einsum('pmqm->pq', MO[:, :nocc, :, :nocc])

### Build D matrices
Focc = F[np.arange(nocc), np.arange(nocc)].flatten()
Fvirt = F[np.arange(nocc, nvirt + nocc), np.arange(nocc, nvirt + nocc)].flatten()

Dia = Focc.reshape(-1, 1) - Fvirt
Dijab = Focc.reshape(-1, 1, 1, 1) + Focc.reshape(-1, 1, 1) - Fvirt.reshape(-1, 1) - Fvirt

### Construct initial guess

# t^a_i
t1 = np.zeros((nocc, nvirt))
# t^{ab}_{ij}
MOijab = MO[:nocc, :nocc, nocc:, nocc:]
t2 = MOijab / Dijab

### Compute MP2 in MO basis set to make sure the transformation was correct
MP2corr_E = np.einsum('ijab,ijab->', MOijab, t2)/4
MP2_E = SCF_E + MP2corr_E

print 'MO based MP2 correlation energy: %.8f' % MP2corr_E
print 'MP2 total energy:       %.8f' % MP2_E
compare_values(energy('mp2'), MP2_E, 6, 'MP2 Energy')

### Setup DIIS
diis_vals = []
diis_diffs = []
diis_size = numpy_memory - memory_footprint
max_diis = int(diis_size / ((t1.nbytes + t2.nbytes) / 1E9)) 
if max_diis < 4:
    clean()
    raise Exception('Require at least %4.2f GB of memory for DIIS' % (4 * ((t1.nbytes + t2.nbytes) / 1E9)) + memory_footprint)

print '\n%4.2f GB reserved for t2 DIIS vectors.' % diis_size
print 'Maximum DIIS vector size is %d.\n' % max_diis 

### Start Iterations
E_conv = 1.e-12
maxiter = 5
CCSDcorr_E_old = 0.0

for CCSD_iter in range(1, maxiter + 1):
    
    # Add DIIS vector
    diis_vals = [np.concatenate((t1.ravel(), t2.ravel()))] + diis_vals
    if CCSD_iter >= 2:
        diis_diffs = [diis_vals[0] - diis_vals[1]] + diis_diffs

    if CCSD_iter >= 3:
        # Limit size of DIIS vector
        if (len(diis_diffs) > max_diis) or (len(diis_diffs) > 10):
            del diis_vals[-1]
            del diis_diffs[-1]

        # Build error matrix B
        diis_size = len(diis_diffs)

        #Build B matrices
        B = np.ones((diis_size + 1, diis_size + 1)) * -1
        B[-1, -1] = 0

        for n1 in range(diis_size):
            for n2 in range(diis_size):
                B[n1, n2] = np.einsum('i,i->', diis_diffs[n1], diis_diffs[n2])

        B[:-1, :-1] /= np.abs(B[:-1, :-1]).max()

        # Build residual vector
        resid = np.zeros(diis_size + 1)
        resid[-1] = -1

        # Solve pulay equations
        diis_ci = SLA.solve(B, resid)

        # Calculate new fock matrix as linear 
        # combination of previous fock matrices
        T = np.zeros_like(diis_vals[0])
        for num in range(diis_size):
            T += diis_ci[num] * diis_vals[num]
        
        t1_size = nocc * nvirt
        t1 = T[:t1_size].reshape(nocc, nvirt)
        t2 = T[t1_size:].reshape(nocc, nocc, nvirt, nvirt)

#    print t1   
    ### Build intermediates
    Fae = build_Fae(t1, t2) 
    Fmi = build_Fmi(t1, t2) 
    Fme = build_Fme(t1, t2) 

    Wmnij = build_Wmnij(t1, t2) 
    Wabef = build_Wabef(t1, t2) 
    Wmbej = build_Wmbej(t1, t2) 

    #### Build RHS side of t1 equations
    rhs_T1  = F[:nocc, nocc:].copy()
    rhs_T1 += np.einsum('ie,ae->ia', t1, Fae)
    rhs_T1 -= np.einsum('ma,mi->ia', t1, Fmi)
    rhs_T1 += np.einsum('imae,me->ia', t2, Fme)
    rhs_T1 -= np.einsum('nf,naif->ia', t1, MO[:nocc, nocc:, :nocc, nocc:])
    rhs_T1 -= 0.5 * np.einsum('imef,maef->ia', t2, MO[:nocc, nocc:, nocc:, nocc:])
    rhs_T1 -= 0.5 * np.einsum('mnae,nmei->ia', t2, MO[:nocc, :nocc, nocc:, :nocc])

    ### Build RHS side of t2 equations
    rhs_T2 = MO[:nocc, :nocc, nocc:, nocc:].copy()

    # P_(ab) t_ijae (F_be - 0.5 t_mb F_me)
    tmp = Fae - 0.5 * np.einsum('mb,me->be', t1, Fme)
    Pab = np.einsum('ijae,be->ijab', t2, tmp)
    rhs_T2 += Pab
    rhs_T2 -= Pab.swapaxes(2, 3)

    # P_(ij) t_imab (F_mj + 0.5 t_je F_me) 
    tmp = Fmi + 0.5 * np.einsum('je,me->mj', t1, Fme)
    Pij = np.einsum('imab,mj->ijab', t2, tmp)
    rhs_T2 -= Pij
    rhs_T2 += Pij.swapaxes(0, 1)

    tmp_tau = build_tau(t1, t2)
    rhs_T2 += 0.5 * np.einsum('mnab,mnij->ijab', tmp_tau, Wmnij)
    rhs_T2 += 0.5 * np.einsum('ijef,abef->ijab', tmp_tau, Wabef)

    # P_(ij) * P_(ab)
    # (ij - ji) * (ab - ba)
    # ijab - ijba -jiab + jiba
    tmp = np.einsum('ie,ma,mbej->ijab', t1, t1, MO[:nocc, nocc:, nocc:, :nocc])
    Pijab = np.einsum('imae,mbej->ijab', t2, Wmbej)
    Pijab -= tmp

    rhs_T2 += Pijab
    rhs_T2 -= Pijab.swapaxes(2, 3)
    rhs_T2 -= Pijab.swapaxes(0, 1)
    rhs_T2 += Pijab.swapaxes(0, 1).swapaxes(2, 3)

    Pij = np.einsum('ie,abej->ijab', t1, MO[nocc:, nocc:, nocc:, :nocc])
    rhs_T2 += Pij
    rhs_T2 -= Pij.swapaxes(0, 1)

    Pab = np.einsum('ma,mbij->ijab', t1, MO[:nocc, nocc:, :nocc, :nocc])
    rhs_T2 -= Pab
    rhs_T2 += Pab.swapaxes(2, 3)

    ### Update t1 and t2 amplitudes
    t1 = rhs_T1 / Dia
    t2 = rhs_T2 / Dijab

    ### Compute CCSD correlation energy
    CCSDcorr_E = np.einsum('ia,ia->', F[:nocc, nocc:], t1)
    CCSDcorr_E += 0.25 * np.einsum('ijab,ijab->', MO[:nocc, :nocc, nocc:, nocc:], t2)
    CCSDcorr_E += 0.5 * np.einsum('ijab,ia,jb->', MO[:nocc, :nocc, nocc:, nocc:], t1, t1)

    ### Print CCSD correlation energy
    print 'CCSD Iteration %3d: CCSD correlation = %.12f   dE = % .5E' % (CCSD_iter, CCSDcorr_E, (CCSDcorr_E - CCSDcorr_E_old))
    if (abs(CCSDcorr_E - CCSDcorr_E_old) < E_conv):
        break

    CCSDcorr_E_old = CCSDcorr_E


CCSD_E = SCF_E + CCSDcorr_E

print '\nFinal CCSD correlation energy:     % 16.10f' % CCSDcorr_E
print 'Total CCSD energy:                 % 16.10f' % CCSD_E
#compare_values(energy('CCSD'), CCSD_E, 6, 'CCSD Energy')

# # [::4] take every 4th, [-5:] take last 5, [::-1] reverse order
# t2_args = np.abs(t2).ravel().argsort()[::2][-5:][::-1]
# t1_args = np.abs(t1).ravel().argsort()[::4][-5:][::-1]

# print '\nLargest t1 amplitudes'
# for pos in t1_args:
#     value = t1.flat[pos]
#     inds = np.unravel_index(pos, t1.shape)
#     print '%4d  %4d |   % 5.10f' % (inds[0], inds[1], value)
# 
# print '\nLargest t2 amplitudes'
# for pos in t2_args:
#     value = t2.flat[pos]
#     inds = np.unravel_index(pos, t2.shape)
#     print '%4d  %4d  %4d  %4d |   % 5.10f' % (inds[0], inds[1], inds[2], inds[3], value)


