# A simple Psi 4 script to compute CCSD from a RHF reference
# Scipy and numpy python modules are required
#
# Algorithms were taken directly from Daniel Crawford's programming website:
# http://sirius.chem.vt.edu/wiki/doku.php?id=crawdad:programming
# Special thanks to Lori Burns for integral help
#
# Created by: Daniel G. A. Smith
# Date: 7/29/14
# License: GPL v3.0
#

import time
import numpy as np
from helper_CC import *
np.set_printoptions(precision=5, linewidth=200, suppress=True)

memory 2 GB

numpy_memory = 2

def pexit():
    clean()
    raise Exception("Exiting Psi4")

molecule mol {
O
H 1 1.1
H 1 1.1 2 104
symmetry c1
}

# molecule mol {
# H
# H 1 0.73257098
# symmetry c1
# }


set {
basis 6-31G
scf_type pk
guess core
mp2_type conv
freeze_core false
e_convergence 1e-10
d_convergence 1e-10
}

# For numpy
compare_psi4 = True

# 
ccsd = helper_CCSD(psi4, energy, mol, memory=2)
ccsd.compute_energy()

CCSDcorr_E = ccsd.ccsd_corr_e
CCSD_E = ccsd.ccsd_e

print('\nFinal CCSD correlation energy:          % 16.10f' % CCSDcorr_E)
print('Total CCSD energy:                      % 16.10f' % CCSD_E)

# Triples correction required o^3v^3 storage due the noddy algorithm
T_Size = (ccsd.nocc ** 3 * ccsd.nvirt ** 3) * 8e-9
print("\nSize of the T3 tensor will be %4.2f GB." % T_Size)
memory_footprint = T_Size * 3.2
if memory_footprint > numpy_memory:
    clean()
    raise Exception("Estimated memory utilization for pertubative triples (%4.2f GB) exceeds numpy_memory limit of %4.2f GB." % (memory_footprint, numpy_memory))

# Construct D3
Focc = np.diag(ccsd.get_F('oo'))
Fvir = np.diag(ccsd.get_F('vv'))
Dijkabc = Focc.reshape(-1, 1, 1, 1, 1, 1) + Focc.reshape(-1, 1, 1, 1, 1) + Focc.reshape(-1, 1, 1, 1)
Dijkabc = Dijkabc - Fvir.reshape(-1, 1, 1) - Fvir.reshape(-1, 1) - Fvir

# P(i/jk) * P(a/bc)
# (ijk - jik - kji) * (abc - bac - cba)
# (ijkabc - ijkbac - ijkcba - jikabc + jikbac + jikcba - kjiabc + kjicac + kjicba)

# Build disconnected t3
tmp = np.einsum('ia,jkbc->ijkabc', ccsd.t1, ccsd.get_MO('oovv'))
t3d = tmp.copy()
t3d -= np.einsum('ijkabc->ijkbac', tmp)
t3d -= np.einsum('ijkabc->ijkcba', tmp)
t3d -= np.einsum('ijkabc->jikabc', tmp)
t3d += np.einsum('ijkabc->jikbac', tmp)
t3d += np.einsum('ijkabc->jikcba', tmp)
t3d -= np.einsum('ijkabc->kjiabc', tmp)
t3d += np.einsum('ijkabc->kjibac', tmp)
t3d += np.einsum('ijkabc->kjicba', tmp)
t3d /= Dijkabc

# Build connected t3
tmp = np.einsum('jkae,eibc->ijkabc', ccsd.t2, ccsd.get_MO('vovv'))
tmp -= np.einsum('imbc,majk->ijkabc', ccsd.t2, ccsd.get_MO('ovoo'))
t3c = tmp.copy()
t3c -= np.einsum('ijkabc->ijkbac', tmp)
t3c -= np.einsum('ijkabc->ijkcba', tmp)
t3c -= np.einsum('ijkabc->jikabc', tmp)
t3c += np.einsum('ijkabc->jikbac', tmp)
t3c += np.einsum('ijkabc->jikcba', tmp)
t3c -= np.einsum('ijkabc->kjiabc', tmp)
t3c += np.einsum('ijkabc->kjibac', tmp)
t3c += np.einsum('ijkabc->kjicba', tmp)
t3c /= Dijkabc

# Compute energy expression
tmp = t3c + t3d
Pert_T = (1.0/36) * np.einsum('ijkabc,ijkabc,ijkabc', t3c, Dijkabc, tmp)

CCSD_T_E = CCSD_E + Pert_T

print('\nPertubative (T) correlation energy:     % 16.10f' % Pert_T)
print('Total CCSD(T) energy:                   % 16.10f' % CCSD_T_E)
if compare_psi4:
    compare_values(energy('CCSD(T)'), CCSD_T_E, 6, 'CCSD(T) Energy')



