# A simple Psi 4 script to compute MP2 from a simple RHF reference
# Scipy and numpy python modules are required
#
# Algorithms were taken directly from Daniel Crawford's programming website:
# http://sirius.chem.vt.edu/wiki/doku.php?id=crawdad:programming
# Special thanks to Lori Burns for integral help

# !!! This is a work in progress and not yet complete !!!

import time
import numpy as np
from scipy import linalg as SLA
np.set_printoptions(precision=5,linewidth=200,suppress=True)
memory 8 GB

def pexit():
    clean()
    raise Exception("Exiting Psi4")

#molecule mol {
#O
#H 1 1.1
#H 1 1.1 2 104
#symmetry c1
#}

molecule mol {
H
H 1 0.73257098
symmetry c1
}


set {
basis 6-31G
scf_type pk
guess core
mp2_type conv
freeze_core false
e_convergence 1e-10
}

# Set defaults
maxiter = 20
E_conv  = 1.0E-10

# Integral generation from Psi4 MintsHelper
t=time.time()
mints = MintsHelper()
S = mints.ao_overlap()
T = mints.ao_potential()
V = mints.ao_kinetic()
I = mints.ao_eri()
print '\nTotal time taken for integrals: %.3f seconds' % (time.time()-t)

# Get nbf and ndocc for closed shell molecules
t=time.time()
Z = 0
for A in range(mol.natom()):
    Z += mol.Z(A)
ndocc = int(Z / 2)
nbf = S.rows(0)

print '\nNumber of occupied orbitals: %d' % ndocc
print 'Number of basis functions: %d' % nbf

# Build H_core
H = np.matrix(np.array(T)+np.array(V))

# Build I and reshape to rank 4 tensor
I = np.array(I).reshape(nbf,nbf,nbf,nbf)

# Orthogonalizer A
A = np.matrix(SLA.sqrtm(S)).I.real

# Calculate initial core guess
Hp = A*H*A
e,C2 = SLA.eigh(Hp)
C = A*C2 
D = C[:,:ndocc]*C[:,:ndocc].T

print '\nTotal time taken for setup: %.3f seconds' % (time.time()-t)

print('\nStart RHF iterations:\n')
t=time.time()
E    = 0.0
Enuc = mol.nuclear_repulsion_energy()
Eold = 0.0

# Lists for DIIS extrapolations
ei = []
fi = []

for SCF_iter in range(1, maxiter + 1):

    # Build fock matrix
    J = np.einsum('pqrs,rs', I, D) 
    K = np.einsum('pqrs,qs', I, D)
    F = H + J*2 - K

    # DIIS error build
    diis_e = F*D*S - S*D*F
    ei = [diis_e] + ei
    fi = [F] + fi

    # SCF energy and update
    SCF_E = np.einsum('ij,ij->', F+H, D) + Enuc

    print 'RHF Iteration %3d: Energy = %.16f   dE = %.5E' % (SCF_iter, SCF_E, (SCF_E - Eold))
    if (abs(SCF_E - Eold) < E_conv):
        break

    Eold = SCF_E

    # Diagonalize Fock matrix
    if SCF_iter <=2:
        Fp = A*F*A
        e,C2 = SLA.eigh(Fp)
        C = A*C2
        D  = C[:, :ndocc]*C[:, :ndocc].T

    # Update using DIIS
    else:
        # Make sure DIIS vector is not to large
        e_cnt = len(ei)
        if e_cnt>6:
            e_cnt = 6

        # Build error matrix B
        B = np.ones((e_cnt+1, e_cnt+1))*-1
        B[-1, -1] = 0
        for num1,e1 in enumerate(ei[:e_cnt]):
            for num2,e2 in enumerate(ei[:e_cnt]):
                val = np.einsum('ij,ij->', e1, e2)
                B[num1, num2] = val

        # Build residual vector
        resid = np.zeros(e_cnt + 1)
        resid[-1] = -1

        # Solve pulay equations
        ci = SLA.solve(B,resid)

        # Calculate new fock matrix as linear 
        # combination of previous fock matrices
        F = np.zeros_like(fi[0])
        for num,c in enumerate(ci[:-1]):
            F += c*fi[num]

        # Diagonalize new Fock matrix
        Fp = A*F*A
        e, C2 = SLA.eigh(Fp)
        C = A*C2
        D  = C[:, :ndocc] * C[:, :ndocc].T

print 'Total time taken for SCF iterations: %.3f seconds \n' % (time.time()-t)

print 'Final SCF energy: %.8f hartree' % SCF_E
SCF_E_psi = energy('scf')
compare_values(SCF_E_psi, SCF_E, 8, 'SCF Energy')


print '\n' + '--'*40
print 'Begining CCSD\n'

#Make spin-orbital MO
t=time.time()
print 'Starting AO -> spatial-orbital MO transformation...'
MO = np.einsum('rJ,pqrs->pqJs', C, I)
MO = np.einsum('pI,pqJs->IqJs', C, MO)
MO = np.einsum('sB,IqJs->IqJB', C, MO)
MO = np.einsum('qA,IqJB->IAJB', C, MO)


MO = np.repeat(MO, 2, axis=0)
MO = np.repeat(MO, 2, axis=1)
MO = np.repeat(MO, 2, axis=2)
MO = np.repeat(MO, 2, axis=3)
p = np.arange(nbf*2, dtype=np.int).reshape(-1, 1, 1, 1) % 2
q = np.arange(nbf*2, dtype=np.int).reshape(-1, 1, 1) % 2
r = np.arange(nbf*2, dtype=np.int).reshape(-1, 1) % 2
s = np.arange(nbf*2, dtype=np.int) % 2


mask1 = (p==r) * (q==s)
value1 = MO.copy()
value1 *= mask1

mask2 = (p==s) * (q==r)
value2 = MO.copy().swapaxes(1, 3)
value2 *= mask2

MO = value1 - value2

# <pr||qs> -> <pq||rs>
MO = MO.swapaxes(1, 2) 
print 'Total time taken for AO -> spin-orbital MO transformation: %.3f seconds \n' % (time.time()-t)

# Update nocc and nvirt
nocc = ndocc*2
nvirt = MO.shape[0] - nocc

#Extend eigenvalues
e = np.repeat(e, 2)
Eocc = e[:nocc]
Evirt = e[nocc:]


# DPD approach to CCSD equations
# See: http://sirius.chem.vt.edu/wiki/doku.php?id=crawdad:programming

# occ orbitals i, j, k, l, m, n
# virt orbitals a, b, c, d, e, f
# all oribitals p, q, r, s, t, u, v

# Compute MP2 in MO basis set to make sure the transformation was correct
t2 = MO[:nocc, :nocc, nocc:, nocc:].copy()
t2 /= (Eocc.reshape(-1, 1, 1, 1) + Eocc.reshape(-1, 1, 1) - Evirt.reshape(-1, 1) - Evirt)

MOijab = MO[:nocc, :nocc, nocc:, nocc:]
MP2corr_E = np.einsum('ijab,ijab->', MOijab, t2)/4
MP2_E = SCF_E + MP2corr_E

print 'Spin-orbital MO based MP2 correlation energy: %.8f' % MP2corr_E
print 'MP2 total energy:       %.8f' % MP2_E
MP2_E_psi = energy('mp2')
compare_values(MP2_E_psi, MP2_E, 6, 'MP2 Energy')


#Bulit Eqn 9: tilde{\Tau}) 
def build_tilde_tau(t1, t2):
    ttau = t2.copy()
    ttau += 0.5 * np.einsum('ia,jb->ijab', t1, t1)
    ttau -= 0.5 * np.einsum('ib,ja->ijab', t1, t1)
    return ttau


#Build Eqn 10: \Tau) 
def build_tau(t1, t2):
    ttau = t2.copy()
    ttau += np.einsum('ia,jb->ijab', t1, t1)
    ttau -= np.einsum('ib,ja->ijab', t1, t1)
    return ttau


#Build Eqn 3:
def build_Fae(t1, t2):
    tmp_tau = build_tilde_tau(t1, t2)

    Fae = F[nocc:, nocc:].copy()
    Fae[np.diag_indices_from(Fae)] = 0

    Fae -= 0.5 * np.einsum('me,ma->ae', F[:nocc, nocc:], t1)
    Fae += np.einsum('mf,mafe->ae', t1, MO[:nocc, nocc:, nocc:, nocc:])
    Fae -= 0.5 * np.einsum('mnaf,mnef->ae', tmp_tau, MO[:nocc, :nocc, nocc:, nocc:])
    return Fae


#Build Eqn 4:
def build_Fmi(t1, t2):
    tmp_tau = build_tilde_tau(t1, t2)

    Fmi = F[:nocc, :nocc].copy()
    Fmi[np.diag_indices_from(Fmi)] = 0

    Fmi += 0.5 * np.einsum('ie,me->mi', t1, F[:nocc, nocc:])
    Fmi += np.einsum('ne,mnie->mi', t1, MO[:nocc, :nocc:, :nocc, nocc:])
    Fmi += 0.5 * np.einsum('inef,mnef->mi', tmp_tau, MO[:nocc, :nocc, nocc:, nocc:])
    return Fmi


#Build Eqn 5:
def build_Fme(t1, t2):
    Fme = F[:nocc, nocc:].copy()
    Fme += np.einsum('nf,mnef->me', t1, MO[:nocc, :nocc, nocc:, nocc:])
    return Fme


#Build Eqn 6:
def build_Wmnij(t1, t2):
    tmp_tau = build_tau(t1, t2)

    Wmnij = MO[:nocc, :nocc, :nocc, :nocc].copy()

    Pij = np.einsum('je,mnie->mnij', t1, MO[:nocc, :nocc, :nocc, nocc:])
    Wmnij += Pij
    Wmnij -= Pij.swapaxes(-1, -2)

    Wmnij += 0.25 * np.einsum('ijef,mnef->mnij', tmp_tau, MO[:nocc, :nocc, nocc:, nocc:])
    return Wmnij

#Build Eqn 7:
def build_Wabef(t1, t2):
    tmp_tau = build_tau(t1, t2)

    Wabef = MO[nocc:, nocc:, nocc:, nocc:].copy()

    Pab = np.einsum('mb,amef->abef', t1, MO[nocc:, :nocc, nocc:, nocc:])
    Wabef -= Pab
    Wabef += Pab.swapaxes(0, 1)

    Wabef += 0.25 * np.einsum('mnab,mnef->abef', tmp_tau, MO[:nocc, :nocc, nocc:, nocc:])
    return Wabef

#Build Eqn 8:
def build_Wmbej(t1, t2):
    Wmbej = MO[:nocc, nocc:, nocc:, :nocc].copy()

    Wmbej += np.einsum('jf,mbef->mbej', t1, MO[:nocc, nocc:, nocc:, nocc:])

    Wmbej -= np.einsum('nb,mnej->mbej', t1, MO[:nocc, :nocc, nocc:, :nocc])

    tmp = 0.5 * t2 + np.einsum('jf,nb->jnfb', t1, t1)
    Wmbej -= np.einsum('jnfb,mnef->mbej', tmp, MO[:nocc, :nocc, nocc:, nocc:])
    return Wmbej


# Build so Fock matirx

# Update Hcore
# Also turn H remove np.matrix class by using H.A
# np.matrix is no longer required anywhere
#H = np.einsum('uj,vi,uv', C, C, H.A)
#H = np.repeat(H, 2, axis=0)
#H = np.repeat(H, 2, axis=1)
#p = np.arange(H.shape[0], dtype=np.int).reshape(-1, 1) % 2
#q = np.arange(H.shape[0], dtype=np.int) % 2
#H *= (p==q)
#F = H + np.einsum('pmqm->pq', MO[:, :nocc, :, :nocc])
#
#F[np.diag_indices_from(F)] = e
F = np.diag(e)


# Build D matrices

# use matrix.A to access underlying numpy array
Focc = F[np.arange(nocc), np.arange(nocc)].flatten()
Fvirt = F[np.arange(nocc, nvirt+nocc), np.arange(nocc, nvirt+nocc)].flatten()

Dia = Focc.reshape(-1, 1) - Fvirt
Dijab = Focc.reshape(-1, 1, 1, 1) + Focc.reshape(-1, 1, 1) - Fvirt.reshape(-1, 1) - Fvirt

# Construct initial guess

# t^a_i
t1 = np.zeros((nocc, nvirt))

# t^{ab}_{ij}
# Special note: the .copy() must be here or we simply create a view.
# If we create a view and then operate in place we modify the MO array
eps = (Eocc.reshape(-1, 1, 1, 1) + Eocc.reshape(-1, 1, 1) - Evirt.reshape(-1, 1) - Evirt)
t2 = MO[:nocc, :nocc, nocc:, nocc:].copy() / Dijab

T2SO_MP2corr_E = np.einsum('ijab,ijab->', t2, MO[:nocc, :nocc, nocc:, nocc:])/4
print 'T2*<ij||ab> spin-orbital MO based MP2 correlation energy: %.8f' % T2SO_MP2corr_E

#pexit()

### Start Iterations
for x in range(20):
    Fae = build_Fae(t1, t2) 
    Fmi = build_Fmi(t1, t2) 
    Fme = build_Fme(t1, t2) 
    Wmnij = build_Wmnij(t1, t2) 
    Wabef = build_Wabef(t1, t2) 
    Wmbej = build_Wmbej(t1, t2) 
    
    # Build RHS side of T1 equations
    rhs_T1 = F[:nocc, nocc:].copy()
    rhs_T1 += np.einsum('ie,ae->ia', t1, Fae)
    rhs_T1 -= np.einsum('ma,mi->ia', t1, Fmi)
    rhs_T1 += np.einsum('imae,me->ia', t2, Fme)
    rhs_T1 -= np.einsum('nf,naif->ia', t1, MO[:nocc, nocc:, :nocc, nocc:])
    rhs_T1 -= 0.5 * np.einsum('imef,maef->ia', t2, MO[:nocc, nocc:, nocc:, nocc:])
    rhs_T1 -= 0.5 * np.einsum('mnae,nmei->ia', t2, MO[:nocc, :nocc, nocc:, :nocc])
    
    
    # Build RHS side of T2 equations
    rhs_T2 = MO[:nocc, :nocc, nocc:, nocc:].copy()
    
    # P_(ab) t_ijae (F_be - 0.5 t_mb  F_me)
    tmp = Fae - 0.5 * np.einsum('mb,me->be', t1, Fme)
    Pab = np.einsum('ijae,be->ijab', t2, tmp)
    rhs_T2 += Pab
    rhs_T2 -- Pab.swapaxes(-1, -2)
    
    # P_(ij) t_imab (F_mj + 0.5 
    tmp = Fmi + 0.5 * np.einsum('je,me->mj', t1, Fme)
    Pij = np.einsum('imab,mj->ijab', t2, tmp)
    rhs_T2 -= Pij
    rhs_T2 += Pij.swapaxes(0, 1)
    
    rhs_T2 += 0.5 * np.einsum('mnab,mnij->ijab', t2, Wmnij)
    rhs_T2 += 0.5 * np.einsum('ijef,abef->ijab', t2, Wabef)
    
    # P_(ij) * P_(ab)
    # (ij - ji) * (ab - ba)
    # ijab - ijba -jiab + jiba
    tmp = np.einsum('ie,ma,mbej->ijab', t1, t1, MO[:nocc, nocc:, nocc:, :nocc])
    Pijab = np.einsum('imae,mbej->ijab', t2, Wmbej) - tmp
    rhs_T2 += Pijab
    rhs_T2 -= Pijab.swapaxes(-1, -2)
    rhs_T2 -= Pijab.swapaxes(0, 1)
    rhs_T2 += Pijab.swapaxes(0, 1).swapaxes(-1, -2)
    
    Pij = np.einsum('ie,abej->ijab', t1, MO[nocc:, nocc:, nocc:, :nocc])
    rhs_T2 += Pij
    rhs_T2 -= Pij.swapaxes(0, 1)
    
    Pij = np.einsum('ma,mbij->ijab', t1, MO[:nocc, nocc:, :nocc, :nocc])
    rhs_T2 -= Pij
    rhs_T2 += Pij.swapaxes(-1, -2)
    
    
    # Update T1 and T2 amplitudes
    t1 = rhs_T1/Dia
    t2 = rhs_T2/Dijab
    
    # Compute CCSD correlation energy
    CCSDcorr_E = np.einsum('ia,ia->', F[:nocc, nocc:], t1)
    CCSDcorr_E += 0.25 * np.einsum('ijab,ijab->', MO[:nocc, :nocc, nocc:, nocc:], t2)
    CCSDcorr_E += 0.5 * np.einsum('ijab,ia,jb->', MO[:nocc, :nocc, nocc:, nocc:], t1, t1)


    print 'Current CCSD correlation energy: %.8f' % CCSDcorr_E

print CCSDcorr_E + SCF_E
print 'Psi4 CCSD energy: %f' % -1.15157347084
#print energy('CCSD')


